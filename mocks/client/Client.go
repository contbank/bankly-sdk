// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	context "context"

	client "github.com/contbank/bankly-sdk/client"

	http "net/http"

	mock "github.com/stretchr/testify/mock"
)

// Client is an autogenerated mock type for the Client type
type Client struct {
	mock.Mock
}

type Client_Expecter struct {
	mock *mock.Mock
}

func (_m *Client) EXPECT() *Client_Expecter {
	return &Client_Expecter{mock: &_m.Mock}
}

// Do provides a mock function with given fields: request
func (_m *Client) Do(request *http.Request) (*client.BanklyResponse, error) {
	ret := _m.Called(request)

	var r0 *client.BanklyResponse
	if rf, ok := ret.Get(0).(func(*http.Request) *client.BanklyResponse); ok {
		r0 = rf(request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*client.BanklyResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*http.Request) error); ok {
		r1 = rf(request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_Do_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Do'
type Client_Do_Call struct {
	*mock.Call
}

// Do is a helper method to define mock.On call
//  - request *http.Request
func (_e *Client_Expecter) Do(request interface{}) *Client_Do_Call {
	return &Client_Do_Call{Call: _e.mock.On("Do", request)}
}

func (_c *Client_Do_Call) Run(run func(request *http.Request)) *Client_Do_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*http.Request))
	})
	return _c
}

func (_c *Client_Do_Call) Return(_a0 *client.BanklyResponse, _a1 error) *Client_Do_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// Get provides a mock function with given fields: ctx, endpoint
func (_m *Client) Get(ctx context.Context, endpoint string) (*client.BanklyResponse, error) {
	ret := _m.Called(ctx, endpoint)

	var r0 *client.BanklyResponse
	if rf, ok := ret.Get(0).(func(context.Context, string) *client.BanklyResponse); ok {
		r0 = rf(ctx, endpoint)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*client.BanklyResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, endpoint)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type Client_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//  - ctx context.Context
//  - endpoint string
func (_e *Client_Expecter) Get(ctx interface{}, endpoint interface{}) *Client_Get_Call {
	return &Client_Get_Call{Call: _e.mock.On("Get", ctx, endpoint)}
}

func (_c *Client_Get_Call) Run(run func(ctx context.Context, endpoint string)) *Client_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Client_Get_Call) Return(_a0 *client.BanklyResponse, _a1 error) *Client_Get_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// NewRequest provides a mock function with given fields: ctx, method, endpoint, payload
func (_m *Client) NewRequest(ctx context.Context, method string, endpoint string, payload interface{}) (*http.Request, error) {
	ret := _m.Called(ctx, method, endpoint, payload)

	var r0 *http.Request
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) *http.Request); ok {
		r0 = rf(ctx, method, endpoint, payload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Request)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, interface{}) error); ok {
		r1 = rf(ctx, method, endpoint, payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_NewRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewRequest'
type Client_NewRequest_Call struct {
	*mock.Call
}

// NewRequest is a helper method to define mock.On call
//  - ctx context.Context
//  - method string
//  - endpoint string
//  - payload interface{}
func (_e *Client_Expecter) NewRequest(ctx interface{}, method interface{}, endpoint interface{}, payload interface{}) *Client_NewRequest_Call {
	return &Client_NewRequest_Call{Call: _e.mock.On("NewRequest", ctx, method, endpoint, payload)}
}

func (_c *Client_NewRequest_Call) Run(run func(ctx context.Context, method string, endpoint string, payload interface{})) *Client_NewRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(interface{}))
	})
	return _c
}

func (_c *Client_NewRequest_Call) Return(_a0 *http.Request, _a1 error) *Client_NewRequest_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// Patch provides a mock function with given fields: ctx, endpoint, payload
func (_m *Client) Patch(ctx context.Context, endpoint string, payload interface{}) (*client.BanklyResponse, error) {
	ret := _m.Called(ctx, endpoint, payload)

	var r0 *client.BanklyResponse
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *client.BanklyResponse); ok {
		r0 = rf(ctx, endpoint, payload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*client.BanklyResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, interface{}) error); ok {
		r1 = rf(ctx, endpoint, payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_Patch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Patch'
type Client_Patch_Call struct {
	*mock.Call
}

// Patch is a helper method to define mock.On call
//  - ctx context.Context
//  - endpoint string
//  - payload interface{}
func (_e *Client_Expecter) Patch(ctx interface{}, endpoint interface{}, payload interface{}) *Client_Patch_Call {
	return &Client_Patch_Call{Call: _e.mock.On("Patch", ctx, endpoint, payload)}
}

func (_c *Client_Patch_Call) Run(run func(ctx context.Context, endpoint string, payload interface{})) *Client_Patch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *Client_Patch_Call) Return(_a0 *client.BanklyResponse, _a1 error) *Client_Patch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// Post provides a mock function with given fields: ctx, endpoint, payload
func (_m *Client) Post(ctx context.Context, endpoint string, payload interface{}) (*client.BanklyResponse, error) {
	ret := _m.Called(ctx, endpoint, payload)

	var r0 *client.BanklyResponse
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *client.BanklyResponse); ok {
		r0 = rf(ctx, endpoint, payload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*client.BanklyResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, interface{}) error); ok {
		r1 = rf(ctx, endpoint, payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_Post_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Post'
type Client_Post_Call struct {
	*mock.Call
}

// Post is a helper method to define mock.On call
//  - ctx context.Context
//  - endpoint string
//  - payload interface{}
func (_e *Client_Expecter) Post(ctx interface{}, endpoint interface{}, payload interface{}) *Client_Post_Call {
	return &Client_Post_Call{Call: _e.mock.On("Post", ctx, endpoint, payload)}
}

func (_c *Client_Post_Call) Run(run func(ctx context.Context, endpoint string, payload interface{})) *Client_Post_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *Client_Post_Call) Return(_a0 *client.BanklyResponse, _a1 error) *Client_Post_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// Put provides a mock function with given fields: ctx, endpoint, payload
func (_m *Client) Put(ctx context.Context, endpoint string, payload interface{}) (*client.BanklyResponse, error) {
	ret := _m.Called(ctx, endpoint, payload)

	var r0 *client.BanklyResponse
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *client.BanklyResponse); ok {
		r0 = rf(ctx, endpoint, payload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*client.BanklyResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, interface{}) error); ok {
		r1 = rf(ctx, endpoint, payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_Put_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Put'
type Client_Put_Call struct {
	*mock.Call
}

// Put is a helper method to define mock.On call
//  - ctx context.Context
//  - endpoint string
//  - payload interface{}
func (_e *Client_Expecter) Put(ctx interface{}, endpoint interface{}, payload interface{}) *Client_Put_Call {
	return &Client_Put_Call{Call: _e.mock.On("Put", ctx, endpoint, payload)}
}

func (_c *Client_Put_Call) Run(run func(ctx context.Context, endpoint string, payload interface{})) *Client_Put_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *Client_Put_Call) Return(_a0 *client.BanklyResponse, _a1 error) *Client_Put_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// Request provides a mock function with given fields: ctx, method, endpoint, payload
func (_m *Client) Request(ctx context.Context, method string, endpoint string, payload interface{}) (*client.BanklyResponse, error) {
	ret := _m.Called(ctx, method, endpoint, payload)

	var r0 *client.BanklyResponse
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) *client.BanklyResponse); ok {
		r0 = rf(ctx, method, endpoint, payload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*client.BanklyResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, interface{}) error); ok {
		r1 = rf(ctx, method, endpoint, payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_Request_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Request'
type Client_Request_Call struct {
	*mock.Call
}

// Request is a helper method to define mock.On call
//  - ctx context.Context
//  - method string
//  - endpoint string
//  - payload interface{}
func (_e *Client_Expecter) Request(ctx interface{}, method interface{}, endpoint interface{}, payload interface{}) *Client_Request_Call {
	return &Client_Request_Call{Call: _e.mock.On("Request", ctx, method, endpoint, payload)}
}

func (_c *Client_Request_Call) Run(run func(ctx context.Context, method string, endpoint string, payload interface{})) *Client_Request_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(interface{}))
	})
	return _c
}

func (_c *Client_Request_Call) Return(_a0 *client.BanklyResponse, _a1 error) *Client_Request_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

type mockConstructorTestingTNewClient interface {
	mock.TestingT
	Cleanup(func())
}

// NewClient creates a new instance of Client. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewClient(t mockConstructorTestingTNewClient) *Client {
	mock := &Client{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
